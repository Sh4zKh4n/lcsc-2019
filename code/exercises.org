#+LATEX_HEADER: \usepackage{amsthm}

* Exercises
** Week 1
***  Setting up your programming environment
Follow the instructions in =code/week1= of the GitHub repository to set up a C++
development environment.
***  [LN 2.2] /Uniform distribution on the unit interval/
An RNG engine produces integers $x_i$ in the set $\{0, 1, 2, \ldots, m - 1\}$.
To obtain reals $\omega_i$ that are distributed uniformly in $[0, 1]$ we can
scale a number of different ways, such as:
- $\omega_i = \frac{x_i}{m - 1}$
- $\omega_i = \frac{x_i}{m}$
- $\omega_i = \frac{x_i + 1/2}{m}$
Discuss the advantages and disadvantages of these different scalings. Which one
would prefer?
***  [LN 2.3] /Periods of poorly chosen iterations/
1. Compute the period of $(7x + 3) \bmod{10}$.
2. Compute the period of $5x \bmod{13}$ and of $7x \bmod{13}$.
3. Compute the period of $(3x + 4) \bmod{60}$. Note that, even for large $m$,
   the period can become small.
***  [LN 2.6]
1. Design an abstract class =rng=, that will serve as a base class for all RNG
   engines that you implement. What (pure virtual) functions should it have?
2. Design a class =lcrng= that inherits from =rng=. This class should allow a
   user to choose the parameters $(a, c, m)$ and the seed for the RNG.
3. Predefine a number of LCRNGs (i.e., with specific parameters) in your
   library. One way to accomplish this is by making a class such as
   =park_miller= that inherits from =lcrng=, but has a simpler constructor that
   only takes the seed. You should at least predefine the LCRNGs that are listed
   in Table 2.1 of the lecture notes.
4. Implement Schrage's trick for the generators that it applies to. One
   straightforward way to do this (but definitely not the only correct way), is
   to have a =shrage_lcrng= class that inherits from =lcrng= with a different
   implementation for computing the next iterate (by overloading the member
   function that computes this).
** Week 2
*** Building a library
Follow the instructions in =code/week2= of the GitHub repository to learn about
dealing with multiple files.
***  [LN 2.9] /Implementation of the rejection method/
1. Design an abstract class =distribution=, that will serve as a base class for
   all the distributions that we implement. What (pure virtual) functions should
   it have?
2. Implement a uniform distribution class =uniform_distribution=, that is able
   to sample random reals in an interval $[a, b]$.
3. Design an interface that allows you to test your distribution. A quick (but
   inexact) way to do this is to observe the distribution optically, by e.g.
   looking at a histogram of the generated samples. You are free to choose how
   you want to realize this. For example, you can implement a C++ function that
   shows a histogram in your terminal, or even output the samples to a file and
   use your favorite environment (Python, MATLAB, Mathematica) to generate the
   plots.
4. Choose your favorite distribution $f$. Using the uniform distribution that you
   implemented before, realize $f$ by implementing the rejection method. Can you
   design it in such a way that you only need to implement the rejection method
   once, and reuse this implementations for other choices of $f$?
*** (Hand-in) [LN 2.7] /Correctness of the inversion method/
Prove the following theorem:

#+BEGIN_QUOTE
*Theorem 2.1 (Inversion method)*. Let $f$ be a distribution function with cumulative distribution $F$. Let $U$ be a random variable on $\Omega$ with
uniform distribution $[0,1]$. Then the random variable $X \equiv F^1(U)$ on $\Omega$ has distribution function $f$.
#+END_QUOTE

You may take $\Omega = [0, 1]$, and $U(\omega) = \omega$. If $F$ is continuous,
then we have that $F(x) = \int_{-\infty}^x f(y) dy$.
*** (Hand-in) [LN 2.8] /Inverse distribution functions/
Let $u \in [0, 1]$ and $\lambda, \sigma > 0$.

1. Verify that the cdf for an /exponential distribution/:
   $$F(x) = 1 - e^{-\lambda x}$$
   has inverse $F^{-1}(u) = -1/\lambda \log(1 - u)$.
2. Verify that the cdf for a /Cauchy distribution/:
   $$F(x) = 1/2 - 1/\pi \arctan(x / \sigma)}$$
   has inverse $F^{-1}(u) = \sigma \tan(\pi(u - 1/2))$.
*** /Implementation of the inversion method/
1. Implement a Cauchy distribution =cauchy_distribution= by using the inverse of its cdf that you
   computed in the hand-in.
2. Show that:
   $$\frac{1}{2 \pi} \exp(-x^2 / 2) \leq \frac{1}{\pi (2 + x^2)}.$$
3. Implement a Gaussian distribution =normal_distribution= in two ways: by using
   the rejection method together with the Cauchy distribution that you
   implemented, and by using the rejection method together with the uniform
   distribution. You will need to cut the distributions off to make sure they
   have finite support.
4. Generate a large amount $(\geq 10^6)$ of normally distributed numbers in both
   implementations, while timing the execution speed. You can do a rough timing
   of a program in your terminal by running e.g.:
   #+BEGIN_SRC bash
   time ./test_normal_uniform
   time ./test_normal_cauchy
   #+END_SRC
   How does the underlying distribution impact the runtime of your program? What
   would you roughly expect by analyzing the two auxiliary distributions?
*** [LN 2.10] /Random permutations of $n$ points/
 Implement a function:
 #+BEGIN_SRC cpp
   std::vector<int> random_permutation(rng& engine, int n);
 #+END_SRC
 that generates a random permutation of the set $\{ 1, \ldots, n \}$.
 1. Draw $n$ numbers in the unit interval $[0, 1]$, using your
    =uniform_distribution= class. This gives you a sequence $(\omega_1,
    \omega_2, \ldots, \omega_n)$.
 2. Define the permutation $\pi$ as the permutation that sorts this sequence.
    You can find this permutation as follows:
    1. Initialize the return list with $1, \ldots, n$ (hint: look up how to use
       =std::vector= and =std::iota=).
    2. Sort this list using =std::sort=, but use a custom compare function, that
       sorts it according to the sequence of uniform samples that you generated.
 3. Prove (on paper) for $n = 2$ and $n = 3$ that the generated permutation is
    uniformly distributed.
** Week 3
*** Understanding header-only libraries
Look at the example code in =code/week3= of the GitHub repository. Make sure you
understand the basics of templates, the ODR, and translation units. You can use
this code as a starting point, or simply as inspiration for your own RNG
library.

You are free to choose whether you want to employ templates for your engines and
distributions, or to use fixed width numeric types. In any case, think about
(and discuss in your report) some of the advantages and disadvantages of using
templates.

From now on, maintain a =CMakeLists.txt= file in your code that allows it to be
easily built by other programmers.
*** Full period for a linear generator $T$
Prove that a non-singular matrix $T$ generates a non-zero sequence of full
period for all non-zero seeds, if and only if the order of $T$ is $2^{n} - 1$
(in group of non-singular $n \times n$ matrices).
*** Finding appropriate Xorshift parameters
Consider the linear generator functions:
  \begin{equation}
  T = (\text{Id} + L^a)(\text{Id} + R^b)
  \label{eq:try1}
  \end{equation}
  \begin{equation}
  T = (\text{Id} + L^a)(\text{Id} + R^b)(\text{Id} +
  L^c)
  \label{eq:try2}
  \end{equation}
1. Verify experimentally that for (\ref{eq:try1}) no $a, b$ give $T$ with
   required period for $n = 32$
2. Give all triples $(a, b, c)$ for which (\ref{eq:try2}) has full period.

/Hint:/ Use the previous exercise.
*** Implementing Xorshift
 1. Implement a class =xorshift= that inherits from =rng= and implements a Xorshift
    generator for a set of parameters defined by the user.
 2. Predefine a number of Xorshift engines.
*** (Optional) Implementing MT19337
Research online how the Mersenne Twister is defined. Implement a class =mt19937=
that implements it. You can compare with the =mt19337= implementation from the
=<random>= library to ensure correctness.
** Week 4
*** Using external libraries
Look at the example code in =code/week4= of the GitHub repository. Download and
install the TestU01 library, and test your RNGs against some of its tests.
** Week 6
*** An extension to our RNG library
Look at the example code in =code/week6= of the GitHub repository. Implement
basic Monte Carlo integration (hit-or-miss and simple sampling) of a black box 1D
function represented as an =std::function= object. Your Monte Carlo code should
work for arbitrary functions and with any of the RNG engines you have
implemented.
*** [LN 3.1] The error of the trapezoidal rule.
Show that the remainder:
$$R \equiv \int_a^b f(x) dx - \frac{b - a}{2} (f(a) + f(b))$$
can be expressed as
$$R \equiv \frac{(b - a)^3}{12} f''(\eta)$$
for some $\eta \in [a, b]$.
*** [LN 3.2] The error of the repeated trapezoidal rule
1. Show that the overall error for the repeated trapezoidal rule can be
   expressed as:
   $$R(h) = - \frac{1}{12} h^3 \sum_{i = 1}^k f''(\eta_i),$$
   with $\eta_i \in [x_{i - 1}, x_i]$.
2. Show that this error is bounded by
   $$|R(h)| \leq \frac{b - a}{12} h^2 \max_{x \in [a, b]} |f''(x)|.$$
*** [LN 3.4] Integrating a function with Monte Carlo.
Consider the integral:
$$I = \int_0^1 \sqrt{1 - x^2}~dx.$$
1. Compute this integral using /hit-or-miss/ Monte Carlo.
2. Compute this integral using /simple sampling/ Monte Carlo. 
3. Investigate the behaviour of the remainder as a function of the number of
   `shots' and `sample points'.
** Week 7
*** [LN 3.8] The volume of the $d\text{-dimensional}$ unit sphere
Here we will compare two methods for estimating the volume of the unit sphere in
$d$ dimensions: 1) simple sampling Monte Carlo and 2) low-discrepancy sampling.
We will write the unit (hyper)sphere as $\Omega_d$.

1. The volume $V_d$ of $\Omega_d$ can be written as:
   $$\int_{-1}^1 \cdots \int_{-1}^1 \mathbb{1}_{x_1^2 + \cdots + x_d^2 \leq 1}~dx_d \cdots dx_1,$$
   
   where $\mathbb{1}$ is an indicator function. Explain why there is no
   difference between simple sampling and hit-or-miss Monte Carlo for this
   integral.

2. Alternatively, you can integrate the constant function $1$ over the sphere:
   $$\int_{\Omega_d} 1 ~d\vec{x}.$$
   To do this with repeated 1-dimension integration using simple sampling or low
   discrepancy sampling (with e.g. the Halton sequence). A good way is to
   generalize:
   $$V_2 = 4 \int_0^1 \int_0^{\sqrt{1 - y^2}}~dx dy$$
   to higher dimensions.

3. An analytical formula for the volume $V_d$ is given by:
   $$V_d = \frac{\pi^{d /  2}}{\Gamma(\frac{d}{2} + 1)}.$$
   Generate numerical results for simple sampling and low-discrepancy sampling,
   and compare the error you observe as a function of the number of points $n$
   for various dimensions $d$.

*** (Hand-in) Radiation density in imaging
In an X-ray imaging experiment, penetrating radiation is emitted from various point
sources. The intensity of this radiation decreases with one over the 
distance to the point source squared. In this exercise, we want to estimate the total
amount of radiation for a given /cuboid/ region:
$$V \equiv [x_1, x_2] \times [y_1, y_2] \times [z_1, z_2] \subset \mathbb{R}^3,$$
for a collection of source positions:
$$S = \{ \vec{s}_1, \ldots, \vec{s}_n \}, \quad \vec{s}_i \in \mathbb{R}^3.$$

1. Develop a general strategy to (numerically) evaluate integrals of the form:

 $$\sum_{i = 1}^n \int_V \frac{1}{||\vec{x} - \vec{s}_i||^2} ~ d \vec{x}$$
 
 you can assume that $\vec{s}_i \notin V$.
 
2. Write a C++ program that computes this integral. We let $V = [-1, 1]^3$. We
   consider two different sets of source positions:
   - $n$ equidistant points on a circle around the $x-\text{axis}$ with radius $2$
   - $n$ equidistant points on a helix around the $x-\text{axis}$ with radius $2$, and height $2$.

   (A realistic choice is $n = 100$).
   
3. Report on the efficiency and quality of your method.
   - What is a good value for the number of (sample) points.
   - What is the expected precision?
   - What is the absolute runtime (in seconds) of your integration method.

4. /(Bonus)/ What if we are interested in splitting $V$ along, say, the $x\text{-axis}$
  into two parts that receive the same total radiation. In other words, we want
  to find a $x_1 < c < x_2$ so that:
  $$\sum_{i = 1}^n \int_{x_1}^c \int_{y_1}^{y_2}  \int_{z_1}^{z_2} \frac{1}{||\vec{x} - \vec{s}_i||^2}~dz~dy~dx = \sum_{i = 1}^n \int_{c}^{x_2}  \int_{y_1}^{y_2} \int_{z_1}^{z_2} \frac{1}{||\vec{x} - \vec{s}_i||^2}~dz~dy~dx.$$
  Develop a general stategy for finding $c$. Compute $c$ for the two sets of source
  positions of the previous exercise, for the region $V = [-1, \frac{1}{2}]^3$.
     

/General hints:/
- Some possibly useful identities:
  - The following one-dimensional indefinite integral:
    $$\int \frac{1}{a^2 + x^2}~dx = \frac{1}{a} \arctan \left( \frac{x}{a} \right).$$
  - Addition formula for the arctangent:
    $$\arctan(u) \pm \arctan(v) = \arctan\left(\frac{u \pm v}{1 \mp uv}\right) \pmod \pi \, , \quad u v \ne 1 $$
